<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Non-Billable Time Analysis</title>
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 16px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segue UI', Roboto, sans-serif;
    }
    .filters {
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    select, button {
      margin: 5px;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      min-width: 120px;
    }
    .charts-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    .chart-wrapper {
      background: white;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      height: 400px;
    }
    .summary-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .stat-card {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #4CAF50;
    }
    .stat-label {
      font-size: 14px;
      color: #666;
    }
    #debug {
      padding: 10px;
      margin: 10px 0;
      background-color: #f5f5f5;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div id="debug">Loading...</div>
  <div class="filters">
    <select id="userFilter">
      <option value="all">All Users</option>
    </select>
    <select id="projectFilter">
      <option value="all">All Projects</option>
    </select>
    <select id="taskFilter">
      <option value="all">All Tasks</option>
    </select>
  </div>

  <div class="summary-stats">
    <div class="stat-card">
      <div class="stat-value" id="totalHours">-</div>
      <div class="stat-label">Total Non-Billable Hours</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="avgHoursPerDay">-</div>
      <div class="stat-label">Avg Hours/Day</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="topProject">-</div>
      <div class="stat-label">Top Non-Billable Project</div>
    </div>
  </div>

  <div class="charts-container">
    <div class="chart-wrapper">
      <canvas id="distributionChart"></canvas>
    </div>
    <div class="chart-wrapper">
      <canvas id="trendChart"></canvas>
    </div>
  </div>

  <script>
    // Wait for DOM to be ready
    document.addEventListener('DOMContentLoaded', function() {
      let currentRecords = [];
      let charts = {};

      function log(message, data) {
        const debugDiv = document.getElementById('debug');
        if (debugDiv) {
          const timestamp = new Date().toISOString();
          debugDiv.innerHTML = `${timestamp}: ${message}\n${JSON.stringify(data, null, 2)}`;
          console.log(message, data);
        }
      }

      function validateAndParseRecord(record) {
        return {
          user: record.User || '',
          project: record.Project || '',
          task: record.Task || '',
          startDate: record['Start Date'] || '',
          duration: parseFloat(record['Duration (decimal)']) || 0,
          description: record.Description || '',
          billable: record.Billable === 'Yes'
        };
      }

      function processData(records) {
        // First, ensure we have records
        if (!records || !records.length) {
          log('No records to process', { records });
          return { byUser: {}, projectDistribution: {}, taskDistribution: {} };
        }

        // Filter for non-billable records
        const nonBillableRecords = records.filter(r => r.Billable === 'No');
        log('Non-billable records', { count: nonBillableRecords.length });

        // Group by user and calculate totals
        const byUser = {};
        const projectTotals = {};
        const taskTotals = {};

        nonBillableRecords.forEach(record => {
          const duration = parseFloat(record['Duration (decimal)']) || 0;
          const user = record.User || 'Unknown';
          const project = record.Project || 'Unknown';
          const task = record.Task || 'Unknown';
          
          // Update user totals
          if (!byUser[user]) {
            byUser[user] = [];
          }
          byUser[user].push({
            project,
            task,
            duration,
            startDate: record['Start Date']
          });

          // Update project totals
          projectTotals[project] = (projectTotals[project] || 0) + duration;
          
          // Update task totals
          taskTotals[task] = (taskTotals[task] || 0) + duration;
        });

        // Calculate project distribution for each user
        const projectDistribution = {};
        Object.entries(byUser).forEach(([user, entries]) => {
          projectDistribution[user] = entries.reduce((acc, entry) => {
            acc[entry.project] = (acc[entry.project] || 0) + entry.duration;
            return acc;
          }, {});
        });

        log('Processed data', { 
          userCount: Object.keys(byUser).length,
          projectCount: Object.keys(projectTotals).length,
          taskCount: Object.keys(taskTotals).length
        });

        return {
          byUser,
          projectDistribution,
          projectTotals,
          taskTotals
        };
      }

      function createCharts(data, selectedUser = 'all') {
        const distributionCtx = document.getElementById('distributionChart')?.getContext('2d');
        if (!distributionCtx) return;

        if (charts.distribution) {
          charts.distribution.destroy();
        }

        // Prepare chart data based on selection
        let chartData;
        if (selectedUser === 'all') {
          // Use overall project totals
          chartData = Object.entries(data.projectTotals)
            .sort((a, b) => b[1] - a[1]); // Sort by hours descending
        } else {
          // Use user-specific project distribution
          chartData = Object.entries(data.projectDistribution[selectedUser] || {})
            .sort((a, b) => b[1] - a[1]);
        }

        log('Chart data prepared', {
          selectedUser,
          dataPoints: chartData.length,
          sample: chartData.slice(0, 3)
        });

        charts.distribution = new Chart(distributionCtx, {
          type: 'doughnut',
          data: {
            labels: chartData.map(([project]) => project),
            datasets: [{
              data: chartData.map(([, hours]) => hours),
              backgroundColor: [
                '#4CAF50', '#2196F3', '#FFC107', '#FF5722', '#9C27B0',
                '#795548', '#607D8B', '#E91E63', '#9E9E9E', '#CDDC39'
              ]
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: `Non-Billable Project Distribution - ${selectedUser === 'all' ? 'All Users' : selectedUser}`
              },
              legend: {
                position: 'right'
              }
            }
          }
        });

        const trendCtx = document.getElementById('trendChart')?.getContext('2d');
        if (!trendCtx) return;

        if (charts.trend) {
          charts.trend.destroy();
        }

        // Get entries for selected user or all users
        const entries = selectedUser === 'all' ? 
          Object.values(data.byUser).flat() :
          data.byUser[selectedUser] || [];

        // Create daily totals
        const dailyTotals = {};
        entries.forEach(entry => {
          const date = entry.startDate;
          dailyTotals[date] = (dailyTotals[date] || 0) + entry.duration;
        });

        // Convert to sorted array
        const dailyHours = Object.entries(dailyTotals)
          .sort((a, b) => new Date(a[0]) - new Date(b[0]));

        charts.trend = new Chart(trendCtx, {
          type: 'line',
          data: {
            labels: dailyHours.map(([date]) => date),
            datasets: [{
              label: 'Non-Billable Hours',
              data: dailyHours.map(([, hours]) => hours),
              borderColor: '#4CAF50',
              fill: false,
              tension: 0.1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: `Daily Non-Billable Hours - ${selectedUser === 'all' ? 'All Users' : selectedUser}`
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Hours'
                }
              }
            }
          }
        });
      }

      function updateSummaryStats(data, selectedUser = 'all') {
        const entries = selectedUser === 'all' ? 
          _.flatMap(data.byUser) :
          data.byUser[selectedUser] || [];

        const totalHours = _.sumBy(entries, 'duration');
        const uniqueDays = new Set(entries.map(e => e.startDate)).size;
        const avgHoursPerDay = uniqueDays ? (totalHours / uniqueDays) : 0;

        const topProject = _.chain(entries)
          .groupBy('project')
          .mapValues(group => _.sumBy(group, 'duration'))
          .toPairs()
          .maxBy(1)
          .value();

        const totalHoursEl = document.getElementById('totalHours');
        const avgHoursEl = document.getElementById('avgHoursPerDay');
        const topProjectEl = document.getElementById('topProject');

        if (totalHoursEl) totalHoursEl.textContent = totalHours.toFixed(1);
        if (avgHoursEl) avgHoursEl.textContent = avgHoursPerDay.toFixed(1);
        if (topProjectEl) topProjectEl.textContent = topProject ? topProject[0] : '-';

        log('Summary stats', {
          selectedUser,
          totalHours,
          uniqueDays,
          avgHoursPerDay,
          topProject
        });
      }

      function updateFilters(records) {
        const users = [...new Set(records.map(r => r.User))].sort();
        const projects = [...new Set(records.map(r => r.Project))].sort();
        const tasks = [...new Set(records.map(r => r.Task))].sort();

        const userFilter = document.getElementById('userFilter');
        const projectFilter = document.getElementById('projectFilter');
        const taskFilter = document.getElementById('taskFilter');
        
        if (userFilter) {
          userFilter.innerHTML = '<option value="all">All Users</option>';
          users.forEach(user => userFilter.add(new Option(user, user)));
        }
        
        if (projectFilter) {
          projectFilter.innerHTML = '<option value="all">All Projects</option>';
          projects.forEach(project => projectFilter.add(new Option(project, project)));
        }
        
        if (taskFilter) {
          taskFilter.innerHTML = '<option value="all">All Tasks</option>';
          tasks.forEach(task => taskFilter.add(new Option(task, task)));
        }
      }

      function setupEventListeners() {
        ['userFilter', 'projectFilter', 'taskFilter'].forEach(filterId => {
          const element = document.getElementById(filterId);
          if (element) {
            element.addEventListener('change', () => {
              const selectedUser = document.getElementById('userFilter')?.value || 'all';
              const data = processData(currentRecords);
              createCharts(data, selectedUser);
              updateSummaryStats(data, selectedUser);
            });
          }
        });
      }

      // Initialize Grist
      grist.ready({
        requiredHeight: 800
      });

      // Set up event listeners
      setupEventListeners();

      // Handle incoming data from Grist
      grist.onRecords(records => {
        log('Received records', {
          count: records.length,
          sampleRecord: records[0]
        });

        currentRecords = records;
        updateFilters(records);
        
        const data = processData(records);
        createCharts(data);
        updateSummaryStats(data);
      });
    });
  </script>
</body>
</html>